[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparative methods on reticulate phylogenies",
    "section": "",
    "text": "This repository contains materials for a workshop at the Botany 2023 conference on 2023-07-23. This session is part of the workshop “Methodological advances in reticulate evolution” organized by George Tiley & Claudia Solís-Lemus.\nGoal: learn to analyze trait data using phylogenetic comparative methods (PCMs) on reticulate phylogenies, modelled by phylogenetic networks –also named admixture graphs when modelling closely-related populations. We will use methods implemented PhyloNetworks.\nYou can find and clone the workshop material at this github repository."
  },
  {
    "objectID": "index.html#preparation",
    "href": "index.html#preparation",
    "title": "Comparative methods on reticulate phylogenies",
    "section": "preparation",
    "text": "preparation\nWhat you should do prior to the workshop:\n\ninstall Julia and add it to your PATH\ninstall VSCode or another editor, if you don’t have one already.\ninstall R\n\n\ncustomize VSCode\nIf you use VSCode, like we will demonstrate, then within VSCode:\n\nadd code to your PATH, by opening the command palette (⇧⌘P or Ctrl+Shift+P) then searching for “shell command”. After this step, you can open any folder or document with VSCode by typing code filename or code foldername in the shell.\nwithin VSCode, install the Julia extension\nyou may consider installing Quarto extension but this is not necessary for this workshop —or other cool extensions! e.g. for R, for Python, for LaTeX, etc.\n\n\n\ndownload workshop files\nDownload the data and other files for this workshop. Below we explain 2 alternatives ways: using the shell, or not.\n\nusing the shell and cloning with git:\n\nIn the shell, navigate (cd) to a place on your machine where you want to get the folder.\nThis should not be inside an already existing git repository. To know if we are inside a git folder, we can do git status. We want to get an error message, which would mean that we are not in a git repo.\n\nclone the workshop files with: git clone git@github.com:cecileane/networkPCM-workshop.git. This command will create a folder networkPCM-workshop with the data and .qmd (quarto markdown) files containing the code rendered on this website.\ngo into that folder: cd networkPCM-workshop\n\nwithout the shell:\n\ndownload the folder and unzip it. Its default name may be networkPCM-workshop-main.\nmove it somewhere and/or rename it if desired, to organize your projects\nopen that folder or go inside, or open it with VSCode.\n\n\nThe data are in folder data. The code is in files named like topic*.qmd.\n\n\ninstall packages\nOpen julia, e.g. in a terminal integrated in VSCode. Preferably, open julia from the workshop directory (cloned or downloaded earlier) to make it easier to use this directory as a julia environment.\nThen within julia, install packages including PhyloNetworks and PhyloPlots. For this, we suggest using the environment provided in this tutorial, which consists of the two .toml files that lists which packages to install (in Project.toml) and which versions exactly (in Manifest.toml). These installations will not interfere with other ways you might be using julia. Here is how:\n\ntype ] to switch to package mode\ntype activate . if your current directory is the workshop folder. Otherwise, type activate path-to-workshop-folder to activate the workshop folder as the current julia environment for packages.\ntype instantiate: this command will read the .toml files and install the packages given by these files, at the specific versions listed in these files. It will pre-compile them for the environment, in a way that won’t interfere with other julia environments (if any).\n\nAlternatively, if you want to install these packages in the default or any other environment, type ] to switch to package mode. Julia will show a prompt like this: (networkPCM-workshop) pkg> showing the name of the folder used as environment, followed by “pkg>” to mean that it’s in package mode. Then type this:\nadd CSV, CategoricalArrays, DataFrames\nadd Distributions, StatsBase, StatsModels\nadd RCall, PhyloNetworks, PhyloPlots,\nInstallation may take a while, especially if internet is slow.\nAfter this is done, type delete or backspace to go back to julian mode (exit from package mode). The julia prompt will go back to julia>.\nWe will make use of R within Julia, and of some R functions in specific R packages. Install the ape and viridis packages in R:\nR> install.packages(\"viridis\")\nR> install.packages(\"ape\")"
  },
  {
    "objectID": "topic-overview.html",
    "href": "topic-overview.html",
    "title": "Workshop overview",
    "section": "",
    "text": "Comparative methods are meant to answer questions about trait evolution. In this workshop, we will learn about methods on networks:"
  },
  {
    "objectID": "topic-overview.html#topics-we-will-cover",
    "href": "topic-overview.html#topics-we-will-cover",
    "title": "Workshop overview",
    "section": "topics we will cover",
    "text": "topics we will cover\n\nHow to calibrate a network, if needed\ncontinuous response:\n\nphylogenetic regression & phylogenetic ANOVA when the phylogeny is a network. Predictors can be continuous or discrete.\nhow account for within-species variation in the response trait\nancestral state reconstruction\nhow to measure the impact of gene flow\n\ndiscrete trait\n\nancestral state reconstruction\nwas the trait via gene flow?\n\nHow to visualize the results"
  },
  {
    "objectID": "topic-overview.html#lets-get-started",
    "href": "topic-overview.html#lets-get-started",
    "title": "Workshop overview",
    "section": "let’s get started",
    "text": "let’s get started\nLoad the packages we will use:\n\nusing CSV               # read/write CSV and similar formats\nusing DataFrames        # versatile tabular data format\nusing PhyloNetworks     # includes many utilities\nusing PhyloPlots        # for plotting networks: via R\nusing RCall             # run R within Julia\nusing StatsBase, StatsModels # basic stat functions, e.g. to build regression formulas\nusing Distributions     # to get probabilities and quantiles of common distributions\n\nWe will use data on Polemonium from Rose et al. 2021 and Teo et al. 2023.\n\n\n\nPolemonium californicum, by Jeffrey Rose\n\n\nFor a preview, we can first load the network topology. It was estimated with SNaQ, so its branch lengths are in coalescent units, and it will need to be rooted correctly later.\n\nnet_snaq = readTopology(\"data/polemonium_network_fromSNaQ.phy\");\nR\"par\"(mar=[0,0,0,0], cex=0.7); # 0 margins, cex<1 for smaller 'character expansion'\nplot(net_snaq; showedgelength=true, xlim=[0,18]); # increased limit to see full taxon labels\n\n\n\n\nFigure 1: Polemonium network topology from SNaQ: needs rooting, branch lengths in coalescent units\n\n\n\n\nthen the trait data\n\ntraits_indiv = CSV.File(\"data/polemonium_traits_individual.csv\") |> DataFrame\nsize(traits_indiv) # number of rows and number of columns\n\n(1757, 6)"
  },
  {
    "objectID": "topic-overview.html#how-to-get-help",
    "href": "topic-overview.html#how-to-get-help",
    "title": "Workshop overview",
    "section": "how to get help",
    "text": "how to get help\n\nhelp mode: type ? then the name of the function (or package) you’d like information about. For example, if you type ? then readTopology you should see this:\nhelp?> readTopology\nsearch: readTopology readTopologyLevel1 readMultiTopology readMultiTopologyLevel1\n\nreadTopology(file name)\nreadTopology(parenthetical description)\nreadTopology(IO)\n\nRead tree or network topology from parenthetical format (extended Newick). If the root node has a single child: ignore (i.e. delete from the\ntopology) the root node and its child edge.\n\nInput: text file or parenthetical format directly. The file name may not start with a left parenthesis, otherwise the file name itself would be\ninterpreted as the parenthetical description. Nexus-style comments ([&...]) are ignored, and may be placed after (or instead) of a node name, and\nbefore/after an edge length.\n\nA root edge, not enclosed within a pair a parentheses, is ignored. If the root node has a single edge, this one edge is removed.\nJulia will automatically turn back to julian mode. If you don’t know the exact function name, give it your best try. Julia will indicate functions with similar names.\nshell mode: type ; to type a shell command. When you are done using the shell, type “delete” or “backspace” to return to julian mode.\npackage mode: type ] to access this mode, which provides quick ways to install a package with add ..., change the version of a package you already installed, check what packages and what version you’re currently using with status, etc. Type backspace to return to julian mode.\nR mode, after using the RCall package: type $ to access R. This R session has access to the variables created by Julia, and vice versa. Type backspace to return to julian mode. Doing @rlibrary ggplot2 within julia provides access to the R package ggplot2 package outside the R mode and with easy syntax."
  },
  {
    "objectID": "topic1-netcalibration.html",
    "href": "topic1-netcalibration.html",
    "title": "Network calibration",
    "section": "",
    "text": "If not done during the session before, load necessary packages"
  },
  {
    "objectID": "topic1-netcalibration.html#input-network",
    "href": "topic1-netcalibration.html#input-network",
    "title": "Network calibration",
    "section": "input network",
    "text": "input network\nWe first read the network, as shown in the overview section. In that section, the figure shows that the network needs to be rooted correctely, is missing some edge lengths, and that current edge lengths are in coalescent units. These units are expected to correlate poorly with time, because the number of generations per year can vary significantly between species, and the effective population size can also vary greatly across time species (e.g. bottlenecks at speciation or reticulations) and across species.\nBelow, the calibration method will ignore these branch lengths in coalescent units and use genetic distances instead, in average number of substitutions/site (averaged across genes).\n\nnet_snaq = readTopology(\"data/polemonium_network_fromSNaQ.phy\")\ntipLabels(net_snaq)\n\n17-element Vector{String}:\n \"I23917_JR124_Polemonium_viscosum\"\n \"I23927_JR5496_Polemonium_elusum\"\n \"I26284_JRRS15_Polemonium_eddyense\"\n \"I23919_JR107_Polemonium_chartaceum\"\n \"I26282_JR137_Polemonium_micranthum\"\n \"I23920_JRRS17_Polemonium_occidentale_occidentale\"\n \"I20029_JR11_Polemonium_reptans\"\n \"I23907_JR95_Polemonium_pectinatum\"\n \"I26285_JR136_Polemonium_delicatum\"\n \"I23883_JRRS16_Polemonium_pulcherimum_shastense\"\n \"I20028_JR8_Polemonium_elegans\"\n \"I23905_JRRS10_Polemonium_carneum\"\n \"I23912_JR112_Polemonium_pauciflorum\"\n \"I23921_JR109_Polemonium_viscosum\"\n \"I23914_JR098_Polemonium_brandegeii\"\n \"I23913_JR040_Polemonium_molle\"\n \"I20026_JR32_Polemonium_filicinum\"\n\n\nBefore moving on, let’s simplify taxon names. We have a file that gives the correspondence between tip names in the network to “morph” names in the trait data:\n\nnamemap = CSV.read(\"data/tip_to_morph.csv\", DataFrame);\nfirst(namemap, 5)\n\n\n5×2 DataFrameRowtipmorphStringString311I26282_JR137_Polemonium_micranthummicranthum2I23899_JR133_Polemonium_pulcherrimum_lindleyipulcherrimum_lindleyi3I23916_JR128_Polemonium_pulcherrimum_pulcherrimumpulcherrimum_pulcherrimum4I23925_JRRS20_Polemonium_pulcherrimum_pulcherrimumpulcherrimum_pulcherrimum_25I23883_JRRS16_Polemonium_pulcherimum_shastensepulcherrimum_shastense\n\n\nLet’s build a dictionary to make it easier to do the mapping:\n\ntip2morph = Dict(r[:tip] => r[:morph] for r in eachrow(namemap))\n\nDict{String, String31} with 45 entries:\n  \"I23906_JRRS22_Polemonium_eximium\"            => \"eximium\"\n  \"I23891_JR003_Polemonium_vanbruntiae\"         => \"vanbruntiae\"\n  \"I23901_JR091_Polemonium_occidentale_occiden… => \"occidentale_occidentale_2\"\n  \"I23925_JRRS20_Polemonium_pulcherrimum_pulch… => \"pulcherrimum_pulcherrimum_2\"\n  \"I23892_JR038_Polemonium_foliosissimum\"       => \"filicinum\"\n  \"I23913_JR040_Polemonium_molle\"               => \"foliosissimum_2\"\n  \"I23927_JR5496_Polemonium_elusum\"             => \"elusum_2\"\n  \"I23899_JR133_Polemonium_pulcherrimum_lindle… => \"pulcherrimum_lindleyi\"\n  \"I23904_JRRS18_Polemonium_californicum\"       => \"californicum_2\"\n  \"I23893_JR122_Ericales_Fouquieriaceae_Fouqui… => \"foliosissimum_3\"\n  \"I26285_JR136_Polemonium_delicatum\"           => \"delicatum_2\"\n  \"I23908_JR104_Polemonium_acutiflorum\"         => \"acutiflorum\"\n  \"I26283_JR037_Polemonium_viscosum\"            => \"viscosum\"\n  \"I23903_JR102_Polemonium_flavum\"              => \"flavum\"\n  \"I20027_JR46_Polemonium_alpinum\"              => \"albiflorum\"\n  \"I20028_JR8_Polemonium_elegans\"               => \"elegans\"\n  \"I23898_JRRS25_Polemonium_viscosum\"           => \"aff._viscosum_sp._nov.\"\n  \"I23897_JR5148_Polemonium_elusum\"             => \"elusum\"\n  \"I23889_JR041_Polemonium_molle\"               => \"foliosissimum\"\n  \"I23902_JR101_Polemonium_delicatum\"           => \"delicatum\"\n  \"I23883_JRRS16_Polemonium_pulcherimum_shaste… => \"pulcherrimum_shastense\"\n  \"I23905_JRRS10_Polemonium_carneum\"            => \"carneum_2\"\n  \"I20030_JRVB3_Polemonium_vanbruntiae\"         => \"vanbruntiae_2\"\n  \"I23890_JRRS14_Polemonium_eximium\"            => \"eximium_2\"\n  \"I23907_JR95_Polemonium_pectinatum\"           => \"pectinatum\"\n  ⋮                                             => ⋮\n\n\n\nfor tip in net_snaq.node\n  tip.leaf || continue # if not leaf: continue to next iternation (skip next line)\n  tip.name = tip2morph[tip.name]\nend\n# root the network correctly. Now we can use the short names\nrootatnode!(net_snaq, \"micranthum\") # 1 outgroup: micranthum. otherwise use rootonedge!\n# plot the network to see where we should rotate edges to uncross reticulations\nR\"par\"(mar=[0,0,0,0]); # change default margins to 0\nres = plot(net_snaq, shownodenumber=true);\nres[1:2] # (0.0, 12.1) : default x limits for this network\nfor nodenumber in [-16, -17,-6,-4, -19,-21]\n  rotate!(net_snaq, nodenumber)\nend\nplot(net_snaq, xlim=[0,16]); # extend limits to show full taxon names\n\n\n\n\n\n\n\n(a) before rotating edges\n\n\n\n\n\n\n\n(b) after rotating edges\n\n\n\n\nFigure 1: Polemonium network: rooted"
  },
  {
    "objectID": "topic1-netcalibration.html#input-genetic-distances",
    "href": "topic1-netcalibration.html#input-genetic-distances",
    "title": "Network calibration",
    "section": "input genetic distances",
    "text": "input genetic distances\nTo calibrate the network, we need genetic distances estimated between each pair of taxa. The calibration will find edge lengths in the network to match as best as possible these input pairwise distances between taxa.\nThese distances were obtained by estimating a gene tree for each gene, rescaling the gene trees to decrease rate variation across genes, extracting the pairwise distances from each rescaled gene tree, then average the pairwise distances across genes (see here for how to do this). The results were saved in file data/polemonium_geneticpairwisedistances.csv, which we read below.\n\navD = CSV.read(\"data/polemonium_geneticpairwisedistances.csv\", DataFrame);\ntaxa_long = names(avD) # column names\ntaxa = [tip2morph[name] for name in taxa_long]\n\n17-element Vector{String31}:\n \"aff._viscosum_sp._nov._2\"\n \"elusum_2\"\n \"eddyense\"\n \"chartaceum_2\"\n \"micranthum\"\n \"occidentale_occidentale\"\n \"reptans_2\"\n \"pectinatum\"\n \"delicatum_2\"\n \"pulcherrimum_shastense\"\n \"elegans\"\n \"carneum_2\"\n \"pauciflorum\"\n \"confertum\"\n \"brandegeei\"\n \"foliosissimum_2\"\n \"apachianum\"\n\n\nThe order in which taxa appear in the matrix is important, which is why we extracted the taxa (ordered) from the column names.\n\navD = Matrix(avD) # converting to a matrix removes column names\navD |> maximum # max distance: ≈ 0.038 substitutions/site, averaged across genes\n\n0.038069708207402644"
  },
  {
    "objectID": "topic1-netcalibration.html#run-the-calibration",
    "href": "topic1-netcalibration.html#run-the-calibration",
    "title": "Network calibration",
    "section": "run the calibration",
    "text": "run the calibration\nWe now have the 2 necessary inputs: the network and the pairwise distances. Below, we copy the network into a new network, whose edge lengths will be modified during calibration. We first set all edge lengths to some reasonable starting value, e.g. the maximum genetic pairwise distance divided by the number of taxa.\n\nnet = deepcopy(net_snaq)\n# modify branch lengths for good starting values: 0.03807 max distance / 17 taxa ≈ 0.002\nfor e in net.edge\n    e.length = (e.hybrid ? 0.0 : 0.002)\nend\n\nWe are ready to run the calibration. Its optimization criterion is the sum of squares between the observed distances, and the distances expected from the network (weighted average of tree distances, weighted by γ’s). The calibration function modifies the network’s edge lengths directly. Below, we run the calibration 3 times to make sure branch lengths are optimized thoroughly (each one is very fast).\n\nusing Random; Random.seed!(8732) # for reproducibility: you can pick any other seed\nfmin, xmin, ret = calibrateFromPairwiseDistances!(net, avD, taxa,\n        forceMinorLength0=false, NLoptMethod=:LD_MMA);\nfmin, ret # 0.000575038516459, :FTOL_REACHED\n\n(0.00018470183899352304, :FTOL_REACHED)\n\n\n\nfmin, xmin, ret = calibrateFromPairwiseDistances!(net, avD, taxa,\n        forceMinorLength0=false, NLoptMethod=:LN_COBYLA);\nfmin, ret # fmin increased slightly: score got worse\n\n(0.00018617396017517004, :MAXEVAL_REACHED)\n\n\n\nfmin, xmin, ret = calibrateFromPairwiseDistances!(net, avD, taxa,\n        forceMinorLength0=false, NLoptMethod=:LD_MMA);\nfmin, ret \n\n(0.00018470186946648593, :FTOL_REACHED)\n\n\nLet’s check the estimated edge lengths, in units of substitutions/site for now (as were pairwise distances). We see that there are edges with tiny lengths (e.g. < 1e-5), and a few edges with tiny negative lengths.\n\nsort!([e.length for e in net.edge])\n\n41-element Vector{Float64}:\n -1.7904662127921078e-11\n  9.884093262680499e-6\n  5.34183046749636e-5\n  0.00034393799177601624\n  0.0007010063133440925\n  0.0007844084008373255\n  0.0008069860789016378\n  0.0008750883231353323\n  0.0010021156240143537\n  0.0010144667246464924\n  0.0012491689774331623\n  0.0017106487083121576\n  0.001820879461907711\n  ⋮\n  0.009032745272741213\n  0.009336643215198857\n  0.00960757482265956\n  0.009686943090932907\n  0.009686943090932907\n  0.009947876264206615\n  0.009947876264206615\n  0.010011178662144259\n  0.01070230088222567\n  0.011107456145767353\n  0.011107456145767353\n  0.018177139899410177\n\n\nLet’s replace any negative edge lengths with 0:\n\nfor e in net.edge\n  if e.length < 0 e.length = 0; end\nend\n\nand peek at the resulting network:\n\nR\"par\"(mar=[0,0,0,0]);\nR\"par\"(cex=0.5) # decrease \"character expansion\" for smaller annotations later\nres = plot(net, useedgelength=true, showedgelength=true);\n\n\n\n\nFigure 2: Polemonium network: after calibration, edges drawn proportional to their lengths"
  },
  {
    "objectID": "topic1-netcalibration.html#normalize-the-network-height",
    "href": "topic1-netcalibration.html#normalize-the-network-height",
    "title": "Network calibration",
    "section": "normalize the network height",
    "text": "normalize the network height\nOptional: Let’s normalize our calibrated network to a height of 1, so edge lengths will be unit-less after. When we will analyze trait evolution later, we will get trait variance rates that represent variance accumulation from the root to the tips, instead of being relative to the molecular rate in substitutions/site.\nTo normalize our network, we need to length from the root to the tip. getNodeAges will calculate the “age” of each node, assuming that the network is time-consistent (if there are multiple paths from the root to a given node, all these paths have the same lengths) and ultrametric (all tips are at the same distance from the root). It returns the age of nodes in “pre-order”, so the root comes first.\n\nrootage = getNodeAges(net)[1] # 0.018177\nfor e in net.edge\n    e.length /= rootage\nend\ngetNodeAges(net) |> maximum # 1.0, sanity check\nR\"par\"(mar=[0,0,0,0]);\nplot(net, useedgelength=true, xlim=[1,2.5], showgamma=true);\nplot(net, useedgelength=true, xlim=[1,2.5], style=:majortree, arrowlen=0.07);\n\n\n\n\n\n\n\n(a) standard plotting type\n\n\n\n\n\n\n\n(b) ‘major tree’ plotting type\n\n\n\n\nFigure 3: Polemonium network: after calibration and normalization to height 1\n\n\n\nFinally, let’s save our calibrated network to a file:\n\nwriteTopology(net,\"data/polemonium_network_calibrated.phy\")"
  },
  {
    "objectID": "topic2-phyloANOVA.html",
    "href": "topic2-phyloANOVA.html",
    "title": "Phylogenetic regression",
    "section": "",
    "text": "Code\n# code from prior sections\nusing CSV, DataFrames, PhyloNetworks, PhyloPlots, RCall, StatsBase, StatsModels\nPhylogenetic regression and phylogenetic ANOVA are for:\nHere, we can do this when the phylogeny is a network. The residuals are assumed to be phylogenetically correlated. Residuals capture the variation in the response that deviate from the prediction using the predictor variables.\nIn this tutorial, we will use the following continuous traits:\nWe will use our calibrated network. If you did not run the previous section or started a new julia session, we can read this network from file:"
  },
  {
    "objectID": "topic2-phyloANOVA.html#match-taxon-names",
    "href": "topic2-phyloANOVA.html#match-taxon-names",
    "title": "Phylogenetic regression",
    "section": "match taxon names",
    "text": "match taxon names\nWe start with the case when we have 1 value per species —morph in our case.\n\ntraits_morph = CSV.read(\"data/polemonium_traits_morph.csv\", DataFrame)\nselect!(traits_morph, :morph, :llength, :elevation, :lat)\nfirst(traits_morph, 4)\n\n\n4×4 DataFrameRowmorphllengthelevationlatString31Float64Float64Float641acutiflorum0.1908340.4962.262aff._viscosum_sp._nov.-1.3713.078544.09583albiflorum0.9743912.34741.48554apachianum0.2893642.6883633.927\n\n\nTaxon names are in the column “morph”, but don’t match exactly with the names in the network —somethign quite typical.\n\nsetdiff(tipLabels(net), traits_morph.morph) # names in the network but not in trait df\n\n7-element Vector{String}:\n \"reptans_2\"\n \"delicatum_2\"\n \"carneum_2\"\n \"elusum_2\"\n \"aff._viscosum_sp._nov._2\"\n \"foliosissimum_2\"\n \"chartaceum_2\"\n\n\n\nsetdiff(traits_morph.morph, tipLabels(net)) # names in trait df but not in network\n\n20-element Vector{String}:\n \"acutiflorum\"\n \"aff._viscosum_sp._nov.\"\n \"albiflorum\"\n \"boreale\"\n \"californicum\"\n \"carneum\"\n \"chartaceum\"\n \"delicatum\"\n \"elusum\"\n \"eximium\"\n \"filicinum\"\n \"flavum\"\n \"foliosissimum\"\n \"nevadense\"\n \"occidentale_lacustre\"\n \"pulcherrimum_lindleyi\"\n \"pulcherrimum_pulcherrimum\"\n \"reptans\"\n \"vanbruntiae\"\n \"viscosum\"\n\n\nWe notice that some taxa in the network have a suffix “_2” that is not in the trait data, and that the trait data has extra species.\nLet’s use a regular expression to remove the suffix “_2” from the tip names in the network:\n\nfor tip in net.node\n  tip.name = replace(tip.name, r\"_2$\" => s\"\") # s\"\" to substitute what was found with nothing\nend\nissubset(tipLabels(net), traits_morph.morph) # true: all taxa in the network have data\n\ntrue\n\n\nFinally, let’s reduce our data frame to morphs that are in the network, also something often needed:\n\nsubset!(traits_morph, :morph => ByRow(in(tipLabels(net))))\n\n\n17×4 DataFrameRowmorphllengthelevationlatString31Float64Float64Float641aff._viscosum_sp._nov.-1.3713.078544.09582apachianum0.2893642.6883633.9273brandegeei-0.674882.743540.03244carneum0.756531.00843.22115chartaceum-1.612334.11637.63446confertum-0.4304463.704538.94847delicatum0.03162773.30738.848eddyense-1.219372.74441.31899elegans-1.060162.28746.90410elusum0.213141.69244.714611foliosissimum0.6220952.682538.78612micranthum-0.8648491.12843.744713occidentale_occidentale0.5424572.1442.591614pauciflorum0.2220392.637530.808815pectinatum0.8341570.5547.128316pulcherrimum_shastense-1.044883.1741.384217reptans0.7466430.24239.9954"
  },
  {
    "objectID": "topic2-phyloANOVA.html#phylogenetic-regression",
    "href": "topic2-phyloANOVA.html#phylogenetic-regression",
    "title": "Phylogenetic regression",
    "section": "phylogenetic regression",
    "text": "phylogenetic regression\nLet’s fit our model: a Browian motion by default. The output shows the estimated parameters, confidence intervals for the regression coefficients, and other summary.\n\nfit_bm    = phylolm(@formula(llength ~ elevation + lat), traits_morph, net;\n                    tipnames=:morph) # default model: BM\n\nPhyloNetworkLinearModel\n\nFormula: llength ~ 1 + elevation + lat\n\nModel: Brownian motion\n\nParameter Estimates, using REML:\nphylogenetic variance rate: 0.545368\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────────\n                  Coef.  Std. Error      t  Pr(>|t|)  Lower 95%    Upper 95%\n────────────────────────────────────────────────────────────────────────────\n(Intercept)   4.23012     1.81753     2.33    0.0355   0.331896   8.12834\nelevation    -0.58782     0.160091   -3.67    0.0025  -0.93118   -0.24446\nlat          -0.0805585   0.0391812  -2.06    0.0589  -0.164594   0.00347682\n────────────────────────────────────────────────────────────────────────────\nLog Likelihood: -18.3444303454\nAIC: 44.6888606908\n\n\nPagel’s lambda model can be fitted if the phylogeny is a time-consistent network (all paths from the root to a given node have the same length) and ultrametric:\n\nfit_pagel = phylolm(@formula(llength ~ elevation + lat), traits_morph, net;\n                    model=\"lambda\", tipnames=:morph)\n\n[ Info: Maximum lambda value to maintain positive branch lengths: 1.30752\n\n\nPhyloNetworkLinearModel\n\nFormula: llength ~ 1 + elevation + lat\n\nModel: Pagel's lambda\n\nParameter Estimates, using REML:\nphylogenetic variance rate: 0.582156\nLambda: 1.1075\n\nCoefficients:\n───────────────────────────────────────────────────────────────────────────\n                 Coef.  Std. Error      t  Pr(>|t|)  Lower 95%    Upper 95%\n───────────────────────────────────────────────────────────────────────────\n(Intercept)   4.14696     1.8205     2.28    0.0389   0.242364   8.05155\nelevation    -0.580068    0.160465  -3.61    0.0028  -0.924231  -0.235906\nlat          -0.079338    0.039152  -2.03    0.0622  -0.163311   0.00463469\n───────────────────────────────────────────────────────────────────────────\nLog Likelihood: -18.3375456513\nAIC: 46.6750913026\n\n\n\nWhich model seems best, based on AIC?\nWhat is the estimate of λ, and what does it mean?\nWhich predictors seem to be correlated with log-leaflet-length, based on Wald-type tests?"
  },
  {
    "objectID": "topic2-phyloANOVA.html#accounting-for-within-species-variation",
    "href": "topic2-phyloANOVA.html#accounting-for-within-species-variation",
    "title": "Phylogenetic regression",
    "section": "accounting for within-species variation",
    "text": "accounting for within-species variation\nIf we have access to traits at the individual level, rather than aggregated at the species level, then we can account for within-species variation. It’s best to do so, because ignoring within-species variation (when present) can cause various biases.\nWe start by reading the individual trait data and removing rows for taxa not in the network.\n\ntraits_indiv = CSV.read(\"data/polemonium_traits_individual.csv\", DataFrame)\nsubset!(traits_indiv, :morph => ByRow(in(tipLabels(net))))\nlast(traits_indiv, 4)\n\n\n4×6 DataFrameRowmorphllengthlwidthelevationlatlareaString31Float64Float64Float64Float64Float641reptans0.675492-0.2810380.24239.99540.152892reptans1.235470.1354050.24239.99541.129313reptans0.496727-0.2357220.24239.99540.01943994reptans0.703098-0.1450260.24239.99540.316507\n\n\nHere, the predictors (elevation and latitude) have the same value for all individuals within a species: entered as the average elevation and latiture across a much much bigger sample size for each species. The model below accounts for within-species variation in the response variable, not in the predictor variables.\n\nfit_ind = phylolm(@formula(llength ~ elevation + lat), traits_indiv, net;\n                  tipnames=:morph, withinspecies_var=true)\n\nPhyloNetworkLinearModel\n\nFormula: llength ~ 1 + elevation + lat\n\nModel: Brownian motion\n\nParameter Estimates, using REML:\nphylogenetic variance rate: 0.538129\nwithin-species variance: 0.107484\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────────\n                  Coef.  Std. Error      t  Pr(>|t|)  Lower 95%    Upper 95%\n────────────────────────────────────────────────────────────────────────────\n(Intercept)   4.22609     1.81331     2.33    0.0352   0.336929   8.11526\nelevation    -0.585523    0.16023    -3.65    0.0026  -0.929181  -0.241865\nlat          -0.0804964   0.0391184  -2.06    0.0587  -0.164397   0.00340418\n────────────────────────────────────────────────────────────────────────────\nLog Likelihood: -332.2511620613\nAIC: 674.5023241226\n\n\n\nWhat are the estimated variances?\nDid the estimated regression coefficients change much compared to the previous analysis at the species level?\nHow about the strength of evidence that they correlate with log-leaflet-length, based on Wald-type tests?"
  },
  {
    "objectID": "topic2-phyloANOVA.html#likelihood-ratio-test",
    "href": "topic2-phyloANOVA.html#likelihood-ratio-test",
    "title": "Phylogenetic regression",
    "section": "likelihood ratio test",
    "text": "likelihood ratio test\nWe can get p-values with a likelihood ratio test. For likelihood ratio tests, we need to use the ML criterion, not REML, to compare models with different “fixed” effects. ML tends to underestimate variances compared to REML, however.\n\nfit_ml = phylolm(@formula(llength ~ elevation + lat), traits_indiv, net;\n                reml=false, tipnames=:morph, withinspecies_var=true)\nfit_ml_nolat = phylolm(@formula(llength ~ elevation), traits_indiv, net;\n                reml=false, tipnames=:morph, withinspecies_var=true)\nlrtest(fit_ml_nolat, fit_ml)\n\nLikelihood-ratio test: 2 models fitted on 954 observations\n──────────────────────────────────────────────────────\n     DOF  ΔDOF     LogLik  Deviance   Chisq  p(>Chisq)\n──────────────────────────────────────────────────────\n[1]    4        -330.9506  661.9012                   \n[2]    5     1  -328.7027  657.4054  4.4958     0.0340\n──────────────────────────────────────────────────────"
  },
  {
    "objectID": "topic2-phyloANOVA.html#within-species-variation-using-species-summaries",
    "href": "topic2-phyloANOVA.html#within-species-variation-using-species-summaries",
    "title": "Phylogenetic regression",
    "section": "within-species variation using species summaries",
    "text": "within-species variation using species summaries\nThe data we used above has 1 row per individual, which can lead to a very large data set (considering that we have 17 species):\n\nnrow(traits_indiv)\n\n954\n\n\nand sometimes we don’t have this fine-grained individual-level information anyway. In fact, the method only needs to know the sample size, observed mean and variance of the response trait (log-leaflet-length) within each species. Let’s illustrate how to summarize our data with 1 row per species and extra columns: the number of sampled individuals, their mean and variance within each morph.\n\nnum_nonmissing = x -> length(.!(ismissing.(x)))\ntraits_meanstd = combine( groupby(traits_indiv, :morph),\n  :llength => mean => :llength, # last term = new column name\n  :llength => std => :llength_sd,\n  :llength => num_nonmissing => :llength_n,\n  :elevation => mean => :elevation,\n  :lat => mean => :lat\n)\n\n\n17×6 DataFrameRowmorphllengthllength_sdllength_nelevationlatString31Float64Float64Int64Float64Float641aff._viscosum_sp._nov.-1.3710.269326383.078544.09582apachianum0.2893640.304548622.6883633.9273brandegeei-0.674880.353546582.743540.03244carneum0.756530.236791471.00843.22115chartaceum-1.612330.156378164.11637.63446confertum-0.4304460.290027103.704538.94847delicatum0.03162770.384536503.30738.848eddyense-1.219370.065292732.74441.31899elegans-1.060160.258922212.28746.90410elusum0.213140.260283141.69244.714611foliosissimum0.6220950.3156212742.682538.78612micranthum-0.8648490.345533751.12843.744713occidentale_occidentale0.5424570.395491732.1442.591614pauciflorum0.2220390.313219472.637530.808815pectinatum0.8341570.20499290.5547.128316pulcherrimum_shastense-1.044880.23081783.1741.384217reptans0.7466430.285631490.24239.9954\n\n\nWe can use this input data to fit our phylogenetic regression, thanks to the option y_mean_std=true. This format requires 3 columns for the response variable, containing:\n\nthe mean (one row per species): llength in our case\nthe standard deviation (SD, square-root of the variance) named with suffix “_sd”, llength_sd in our case,\nthe sample size, that is, the number of individuals from which the mean and SDs were calculated, named with suffix “_n”, so llength_n in our case.\n\nNow we fit the model as above using our summarized dataset, except that we use option y_mean_std=true to let the function know about the format, and get the same results as before:\n\nphylolm(@formula(llength ~ elevation + lat), traits_meanstd, net; # same result as fit_ind\n        tipnames=:morph, withinspecies_var=true, y_mean_std=true)\n\nPhyloNetworkLinearModel\n\nFormula: llength ~ 1 + elevation + lat\n\nModel: Brownian motion\n\nParameter Estimates, using REML:\nphylogenetic variance rate: 0.538129\nwithin-species variance: 0.107484\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────────\n                  Coef.  Std. Error      t  Pr(>|t|)  Lower 95%    Upper 95%\n────────────────────────────────────────────────────────────────────────────\n(Intercept)   4.22609     1.81331     2.33    0.0352   0.336929   8.11526\nelevation    -0.585523    0.16023    -3.65    0.0026  -0.929181  -0.241865\nlat          -0.0804964   0.0391184  -2.06    0.0587  -0.164397   0.00340418\n────────────────────────────────────────────────────────────────────────────\nLog Likelihood: -332.2511620613\nAIC: 674.5023241226"
  },
  {
    "objectID": "topic3-asr.html",
    "href": "topic3-asr.html",
    "title": "Ancestral state reconstruction",
    "section": "",
    "text": "Code\n# code from prior sections\nusing CSV, DataFrames, PhyloNetworks, PhyloPlots, RCall, StatsBase, StatsModels\nnet = readTopology(\"data/polemonium_network_calibrated.phy\");\nfor tip in net.node tip.name = replace(tip.name, r\"_2$\" => s\"\"); end\nWe load the data at the species (morph) level and focus on log-leaflet-length, without any predictor to predict ancestral states:\nFrom the intercept coefficient we get a prediction at the root (-0.293 on the log scale) but that’s it."
  },
  {
    "objectID": "topic3-asr.html#predict-ancestral-states",
    "href": "topic3-asr.html#predict-ancestral-states",
    "title": "Ancestral state reconstruction",
    "section": "predict ancestral states",
    "text": "predict ancestral states\nThis is typically called “ancestral state reconstruction” but prediction seems a more accurate term. This technique estimates the mean of nodes in the network: ancestral or extant species, conditional on the data. It’s important to look at prediction intervals, not just a “point” estimate.\n\nasr = ancestralStateReconstruction(fit)\nasr_pred = expectations(asr) # predictions at all nodes\n\n\n39×2 DataFrame14 rows omittedRownodeNumbercondExpectationInt64Float641-50.2574852-8-0.20182837-0.1986634-60.1009815-40.04033086-10-0.516027-120.0315958810-0.2308299-15-0.42143610-18-0.13094611140.035155212-20-0.11102313-22-0.326108⋮⋮⋮2817-0.4277552950.03066333019-1.17776318-1.0548832110.20442233160.621485341-0.8639853520.54210736130.2202293740.81878386-1.023583930.744526\n\n\nThis output is somewhat cryptic though, because each row refers to a node number and it’s unclear which are tips, which are internal nodes, and which node has what number. We can also get prediction intervals (sometimes called confidence intervals) but with the same cryptic ordering of nodes:\n\npredint(asr)\n\n39×2 Matrix{Float64}:\n -0.522479    1.03745\n -0.79781     0.394155\n -0.790367    0.393041\n -0.691256    0.893218\n -0.657143    0.737805\n -1.31901     0.286974\n -0.828789    0.891981\n -0.939729    0.478071\n -1.12753     0.284662\n -0.89236     0.630467\n -0.671926    0.742237\n -0.762605    0.540559\n -1.00861     0.35639\n  ⋮          \n -0.6454     -0.21011\n -0.067455    0.128782\n -1.56893    -0.786602\n -1.206      -0.903747\n  0.0199769   0.388867\n  0.579511    0.663459\n -0.944193   -0.783777\n  0.489289    0.594924\n  0.119035    0.321423\n  0.588948    1.04861\n -1.26665    -0.780508\n  0.645395    0.843657"
  },
  {
    "objectID": "topic3-asr.html#extant-species",
    "href": "topic3-asr.html#extant-species",
    "title": "Ancestral state reconstruction",
    "section": "extant species",
    "text": "extant species\nFirst, we build a data frame to get this information in a more interpretable format for the tips. Below is one way to map the morph names in the order in which they appear in the data, to node numbers in the network:\n\ntipnames_trait = traits.morph\nfunction get_morph_nodenumber(label)\n  i = findfirst(n -> n.name == label, net.node)\n  net.node[i].number\nend\ntipnumber = [get_morph_nodenumber(label) for label in tipnames_trait]\nhcat(tipnames_trait, tipnumber)\n\n17×2 Matrix{Any}:\n \"aff._viscosum_sp._nov.\"   12\n \"apachianum\"               15\n \"brandegeei\"               18\n \"carneum\"                   9\n \"chartaceum\"               20\n \"confertum\"                17\n \"delicatum\"                 5\n \"eddyense\"                 19\n \"elegans\"                   8\n \"elusum\"                   11\n \"foliosissimum\"            16\n \"micranthum\"                1\n \"occidentale_occidentale\"   2\n \"pauciflorum\"              13\n \"pectinatum\"                4\n \"pulcherrimum_shastense\"    6\n \"reptans\"                   3\n\n\nWith this mapping, we can replace the node numbers by the morph names, and add other information from the trait data such as the sample size for each morph:\n\ntipindex_asr = indexin(tipnumber, asr_pred.nodeNumber)\nres_tip = DataFrame(\n      morph     = tipnames_trait, # morph names, ordered as in the trait data frame\n      samplesize= traits.llength_n,\n      observed  = traits.llength,\n      predicted = asr_pred.condExpectation[tipindex_asr],\n      low       = predint(asr)[tipindex_asr,1],\n      high      = predint(asr)[tipindex_asr,2]\n  )\n\n\n17×6 DataFrameRowmorphsamplesizeobservedpredictedlowhighString31Int64Float64Float64Float64Float641aff._viscosum_sp._nov.38-1.371-1.36551-1.47801-1.253022apachianum620.2893640.2874070.1993110.3755023brandegeei58-0.67488-0.673295-0.764401-0.5821894carneum470.756530.7532330.6520090.8544575chartaceum16-1.61233-1.59963-1.77254-1.426726confertum10-0.430446-0.427755-0.6454-0.210117delicatum500.03162770.0306633-0.0674550.1287828eddyense3-1.21937-1.17776-1.56893-0.7866029elegans21-1.06016-1.05488-1.206-0.90374710elusum140.213140.2044220.01997690.38886711foliosissimum2740.6220950.6214850.5795110.66345912micranthum75-0.864849-0.863985-0.944193-0.78377713occidentale_occidentale1730.5424570.5421070.4892890.59492414pauciflorum470.2220390.2202290.1190350.32142315pectinatum90.8341570.818780.5889481.0486116pulcherrimum_shastense8-1.04488-1.02358-1.26665-0.78050817reptans490.7466430.7445260.6453950.843657\n\n\nThe predicted species means are close, but not exactly equal, to the observed means in each sample. This is because phylogenetic relatedness is used to share information across species. Little is shared for species with a large sample size, such as foliosissimum. But for species with a small sample size, such as eddyense, more information is borrowed from closely-related species. This is highlighted below:\n\nfilter(:morph => n -> n in [\"eddyense\",\"foliosissimum\"], res_tip)\n\n\n2×6 DataFrameRowmorphsamplesizeobservedpredictedlowhighString31Int64Float64Float64Float64Float641eddyense3-1.21937-1.17776-1.56893-0.7866022foliosissimum2740.6220950.6214850.5795110.663459"
  },
  {
    "objectID": "topic3-asr.html#ancestral-nodes",
    "href": "topic3-asr.html#ancestral-nodes",
    "title": "Ancestral state reconstruction",
    "section": "ancestral nodes",
    "text": "ancestral nodes\nTo look at ancestral states, it’s best to map the predictions and intervals onto the network. To do so, we will build a data frame containing annotations to be placed at nodes, then plot the network with this data frame as argument.\n\nnodepred = expectationsPlot(asr)\nfirst(nodepred, 4)\n\n\n4×2 DataFrameRownodeNumberPredIntInt64Abstract…1-50.262-8-0.237-0.24-60.1\n\n\n\nR\"par\"(mar=[0,0,0,0]);\nplot(net, nodelabel=nodepred, nodecex=0.8, tipoffset=0.1, xlim=[0,13]);\n\n\n\n\nFigure 1: ancestral state reconstruction: species means conditional on data\n\n\n\n\n\nnodeint = predintPlot(asr)\nfirst(nodeint, 4)\n\n\n4×2 DataFrameRownodeNumberPredIntInt64Abstract…1-5[-0.52, 1.04]2-8[-0.8, 0.39]37[-0.79, 0.39]4-6[-0.69, 0.89]\n\n\n\nR\"par\"(mar=[0,0,0,0]);\nplot(net, nodelabel=nodeint, nodecex=0.7, tipoffset=0.1, xlim=[-0.1,13]);\n\n\n\n\nFigure 2: ancestral state reconstruction: 95% prediction interval"
  },
  {
    "objectID": "topic4-impactgeneflow.html",
    "href": "topic4-impactgeneflow.html",
    "title": "Impact of gene flow",
    "section": "",
    "text": "Code\n# code from prior sections\nusing CSV, DataFrames, PhyloNetworks, PhyloPlots, RCall, StatsBase, StatsModels\nnet = readTopology(\"data/polemonium_network_calibrated.phy\");\nfor tip in net.node tip.name = replace(tip.name, r\"_2$\" => s\"\"); end\ntraits = CSV.read(\"data/polemonium_traits_morph.csv\", DataFrame)\nsubset!(traits, :morph => ByRow(in(tipLabels(net))));\nWhat happened to the trait during gene flow? We can ask this question in various ways."
  },
  {
    "objectID": "topic4-impactgeneflow.html#network-model-versus-tree-model",
    "href": "topic4-impactgeneflow.html#network-model-versus-tree-model",
    "title": "Impact of gene flow",
    "section": "network model versus tree model",
    "text": "network model versus tree model\nFirst, we can investigate if the network (with gene flow) is a better explanation for the trait evolution than a tree. Several trees are displayed in the network, but the tree that represents most of the genome has the “major” hybrid edges, those with inheritance γ>0.5. We can delete all the “minor” hybrid edges (with γ<0.5) as shown below.\n\ntree = majorTree(net)\nR\"par\"(mar=[0,0,0,0]);\nplot(tree, tipoffset=0.05, useedgelength=true, xlim=[1,2.5]);\n\n\n\n\nFigure 1: major tree, drawn proportional to edge lengths\n\n\n\n\n\nfit_net = phylolm(@formula(llength ~ elevation + lat), traits, net;\n                  tipnames=:morph, withinspecies_var=true, y_mean_std=true)\nfit_tree = phylolm(@formula(llength ~ elevation + lat), traits, tree;\n                  tipnames=:morph, withinspecies_var=true, y_mean_std=true)\naic(fit_net), aic(fit_tree)\n\n(674.5023241225919, 675.0140696456297)\n\n\nWhich model seems to fit best: network or major tree?\nNote that this network-vs-tree question applies to the phylogenetic correlation of residuals here. It could be gene flow had an impact on the geographic distribution at reticulations, which impacted evelation and latitude. In that case, this impact would be explained by the predictors that we used, and would not be seen here. But it could appear from a model without any predictors (something you could run if interested).\nWe can check to see how much of a difference it makes on coefficients:\n\ncoeftable(fit_net)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoef.\nStd. Error\nt\nPr(>\nt\n)\n\n\n\n\n(Intercept)\n4.22609\n1.81331\n2.33\n0.0352\n0.336929\n8.11526\n\n\nelevation\n-0.585523\n0.16023\n-3.65\n0.0026\n-0.929181\n-0.241865\n\n\nlat\n-0.0804964\n0.0391184\n-2.06\n0.0587\n-0.164397\n0.00340418\n\n\n\n\n\n\ncoeftable(fit_tree)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoef.\nStd. Error\nt\nPr(>\nt\n)\n\n\n\n\n(Intercept)\n4.11819\n1.81426\n2.27\n0.0395\n0.226996\n8.00938\n\n\nelevation\n-0.602781\n0.155119\n-3.89\n0.0016\n-0.935479\n-0.270083\n\n\nlat\n-0.077632\n0.0392076\n-1.98\n0.0677\n-0.161724\n0.00645985\n\n\n\n\n\nor how much difference it makes on the estimated variance parameters:\n\nround.((sigma2_phylo(fit_net), sigma2_phylo(fit_tree)), sigdigits=4)\n\n(0.5381, 0.5319)\n\n\n\nround.((sigma2_within(fit_net), sigma2_within(fit_tree)), sigdigits=4)\n\n(0.1075, 0.1075)\n\n\nOut of curiousity, we can do this again with the most “minor” tree: where major hybrid edges are deleted and all minor hybrid edges are kept.\n\nminortree = deepcopy(net)\nwhile minortree.numHybrids > 0\n  for e in minortree.edge\n    if e.hybrid && e.isMajor\n      PhyloNetworks.deletehybridedge!(minortree, e) # changes the list of edges\n      break\n    end\n  end\nend\n# plot(minortree, tipoffset=0.05, useedgelength=true, xlim=[1,2.5]);\nfit_minor = phylolm(@formula(llength ~ elevation + lat), traits, minortree;\n                  tipnames=:morph, withinspecies_var=true, y_mean_std=true)\naic(fit_net), aic(fit_tree), aic(fit_minor)\n\n(674.5023241225919, 675.0140696456297, 674.7890396071382)"
  },
  {
    "objectID": "topic4-impactgeneflow.html#transgressive-evolution-at-reticulations",
    "href": "topic4-impactgeneflow.html#transgressive-evolution-at-reticulations",
    "title": "Impact of gene flow",
    "section": "transgressive evolution at reticulations",
    "text": "transgressive evolution at reticulations\nAnother question we may ask is whether the trait at reticulations deviates from the weighted average of its parent populations (immediately before gene flow). Such would be the case if a hybrid species’s trait is outside the range of its parents. This “transgressive” evolution can be modelled with a shift in the trait along the edge just below the reticulation. This shift quantifies the difference between the trait at the hybrid node and the weighted average of the immediate parents.\nThe code below builds a data frame with 1 predictor column per reticulation: this column quantifies the effect of a transgressive shift on each taxon in the phylogeny.\n\ndf_shift = regressorHybrid(net)\n\n\n17×5 DataFrameRowshift_8shift_18shift_25tipNamessumFloat64Float64Float64StringFloat6410.00.00.0micranthum0.020.00.00.0occidentale_occidentale0.030.00.00.0reptans0.040.00.00.0pectinatum0.051.00.00.0delicatum1.061.00.00.0pulcherrimum_shastense1.070.00.00.0elegans0.080.00.00.0carneum0.090.01.00.0elusum1.0100.00.00.0aff._viscosum_sp._nov.0.0110.00.00.0pauciflorum0.0120.00.01.0apachianum1.0130.00.00.0foliosissimum0.0140.00.00.0confertum0.0150.00.00.0brandegeei0.0160.00.00.0eddyense0.0170.00.00.0chartaceum0.0\n\n\nTo know which shift corresponds to which reticulation, we could plot the network and ask to see the edge numbers, as shown below.\nBut the data frame shows us which tips are impacted by each reticulation: - transgressive shift on edge 8: reticulation leading to delicatum and pulcherrimum_shastense, - shift on edge 18: below reticulation leading to elusum - shift on edge 25: below reticulation leading to apachianum. The values in this data frame are the proportion of the genome that each species inherited from the reticulation, based on the network’s γ values. In our case, they are only 0 or 1, but the values could be in between on more complex networks, especially for older reticulations if they were followed by later reticulations.\nNow we can combine our trait data and the new columns that can serve as predictors to model transgressive evolution:\n\ndf = innerjoin(select(traits, :morph, r\"llength\", :elevation, :lat),\n               select(df_shift, Not(:sum)), # excludes the 'sum' column\n               on = :morph => :tipNames) # join our data with shift predictors\n\n\n17×9 DataFrameRowmorphllengthllength_sdllength_nelevationlatshift_8shift_18shift_25String31Float64Float64Int64Float64Float64Float64Float64Float641micranthum-0.8648490.345533751.12843.74470.00.00.02occidentale_occidentale0.5424570.395491732.1442.59160.00.00.03reptans0.7466430.285631490.24239.99540.00.00.04pectinatum0.8341570.20499290.5547.12830.00.00.05delicatum0.03162770.384536503.30738.841.00.00.06pulcherrimum_shastense-1.044880.23081783.1741.38421.00.00.07elegans-1.060160.258922212.28746.9040.00.00.08carneum0.756530.236791471.00843.22110.00.00.09elusum0.213140.260283141.69244.71460.01.00.010aff._viscosum_sp._nov.-1.3710.269326383.078544.09580.00.00.011pauciflorum0.2220390.313219472.637530.80880.00.00.012apachianum0.2893640.304548622.6883633.9270.00.01.013foliosissimum0.6220950.3156212742.682538.7860.00.00.014confertum-0.4304460.290027103.704538.94840.00.00.015brandegeei-0.674880.353546582.743540.03240.00.00.016eddyense-1.219370.065292732.74441.31890.00.00.017chartaceum-1.612330.156378164.11637.63440.00.00.0\n\n\nIf we had a particular interest in the reticulation ancestral to the delicatum + pulcherrimum clade, we could look for evidence of transgressive evolution at that reticulation like this (in leaflet length itself, including any effect correlated with latitude and elevation):\n\nfit_noshift = phylolm(@formula(llength ~ 1), df, net, tipnames=:morph,\n          withinspecies_var=true, y_mean_std=true)\n# using `df` for both, so the no-shift model is recognized as nested in the shifted model\nfit_sh8 = phylolm(@formula(llength ~ shift_8), df, net, tipnames=:morph,\n          withinspecies_var=true, y_mean_std=true)\ncoeftable(fit_sh8) # 95% confidence interval for shift includes 0\naic(fit_noshift), aic(fit_sh8)\n\n(674.853189498432, 675.4984901526377)\n\n\nNote that we fitted the no-shift model with the same data df as the shifted model. The taxa are listed in a different order in df and in the original traits data frame. It helps to use the same data frame for later comparisons. For example, we could run a likelihood ratio test (lrtest) to compare the two models, altough that we requires re-fitting them with ML method instead of the default REML:\n\nfit_noshift_ML = phylolm(@formula(llength ~ 1), df, net, tipnames=:morph,\n          reml=false, withinspecies_var=true, y_mean_std=true)\nfit_sh8_ML = phylolm(@formula(llength ~ shift_8), df, net, tipnames=:morph,\n          reml=false, withinspecies_var=true, y_mean_std=true)\nlrtest(fit_noshift_ML, fit_sh8_ML)\n\nLikelihood-ratio test: 2 models fitted on 954 observations\n──────────────────────────────────────────────────────\n     DOF  ΔDOF     LogLik  Deviance   Chisq  p(>Chisq)\n──────────────────────────────────────────────────────\n[1]    3        -334.6010  669.2021                   \n[2]    4     1  -334.3393  668.6785  0.5235     0.4693\n──────────────────────────────────────────────────────"
  },
  {
    "objectID": "topic5-discrete.html",
    "href": "topic5-discrete.html",
    "title": "Discrete trait",
    "section": "",
    "text": "Code\n# code from prior sections\nusing CSV, DataFrames, PhyloNetworks, PhyloPlots, RCall, StatsBase, StatsModels\nnet = readTopology(\"data/polemonium_network_calibrated.phy\");\nfor tip in net.node tip.name = replace(tip.name, r\"_2$\" => s\"\"); end\ntraits = CSV.read(\"data/polemonium_traits_morph.csv\", DataFrame)\nsubset!(traits, :morph => ByRow(in(tipLabels(net))))\nFor illustrative purposes, we are going to look at the evolution of mean elevation as a discrete variable. We discretize elevation using the threshold 2.3 km below, because the distribution of elevation shows somewhat of a gap around that value, and a reasonable number of morphs both below and above that value."
  },
  {
    "objectID": "topic5-discrete.html#estimating-the-evolutionary-rates",
    "href": "topic5-discrete.html#estimating-the-evolutionary-rates",
    "title": "Discrete trait",
    "section": "estimating the evolutionary rate(s)",
    "text": "estimating the evolutionary rate(s)\nFor binary traits, we can use the :ERSM model, for “equal-rate substition model”:\n\nfit = fitdiscrete(net, :ERSM, dat.morph, select(dat, :elevation))\n\nPhyloNetworks.StatisticalSubstitutionModel:\nEqual Rates Substitution Model with k=2,\n  all rates equal to α=0.67674.\n  rate matrix Q:\n                hi      lo\n        hi       *  0.6767\n        lo  0.6767       *\non a network with 3 reticulations\ndata:\n  17 species\n  1 trait\nlog-likelihood: -11.05965\n\n\nor the more general “binary trait substitution model” :BTSM that does not constrain the two rates to be equal:\n\nfit_uneq = fitdiscrete(net, :BTSM, dat.morph, select(dat, :elevation))\n\nPhyloNetworks.StatisticalSubstitutionModel:\nBinary Trait Substitution Model:\n  rate hi→lo α=0.0\n  rate lo→hi β=0.53883\non a network with 3 reticulations\ndata:\n  17 species\n  1 trait\nlog-likelihood: -10.83348\n\n\nUsing a likelihood ratio test, we see that there is no evidence for unequal rates:\n\nx2 = 2*(loglikelihood(fit_uneq) - loglikelihood(fit))\n\n0.45233716294591275\n\n\n\nimport Distributions: Chisq, ccdf\nccdf(Chisq(1), x2) # p-value: P(Χ² on 1 df > observed x2)\n\n0.5012271575266686"
  },
  {
    "objectID": "topic5-discrete.html#ancestral-state-probabilities",
    "href": "topic5-discrete.html#ancestral-state-probabilities",
    "title": "Discrete trait",
    "section": "ancestral state probabilities",
    "text": "ancestral state probabilities\nWe can calculate ancestral state probabilities like this, but the output data frame is hard to interpret because it’s unclear which node has which number:\n\nasr = ancestralStateReconstruction(fit)\n\n\n39×4 DataFrame14 rows omittedRownodenumbernodelabelhiloInt64StringFloat64Float6411micranthum0.01.022occidentale_occidentale0.01.033reptans0.01.044pectinatum0.01.055delicatum1.00.066pulcherrimum_shastense1.00.077elegans0.01.088carneum0.01.099elusum0.01.01010aff._viscosum_sp._nov.1.00.01111pauciflorum1.00.01212apachianum1.00.01313foliosissimum1.00.0⋮⋮⋮⋮⋮2828280.9866520.01334772929290.965710.03428973030H180.9683770.03162283131310.9233950.07660533232320.4311090.5688913333H200.5243340.4756663434340.617820.382183535350.3707850.6292153636360.3842650.6157353737H190.6869940.3130063838380.6917040.3082963939390.2083870.791613\n\n\nBut we can map the posterior probability of state “hi” onto the network. It is important to use the network stored in the fitted object, to be assured that the node numbers match.\n\nR\"par\"(mar=[0,0,0,0]);\nplot(fit.net, shownodenumber=true, showgamma=true, tipoffset=0.1, xlim=[0,15]);\nplot(fit.net, nodelabel=select(asr, :nodenumber, :hi), tipoffset=0.1, xlim=[0,15]);\n\n\n\n\n\n\n\n(a) showing node numbers\n\n\n\n\n\n\n\n(b) showing the posterior probability of state ‘hi’\n\n\n\n\nFigure 1: network stored in fitted object, to map ancestral state probabilities"
  },
  {
    "objectID": "topic5-discrete.html#effect-of-gene-flow",
    "href": "topic5-discrete.html#effect-of-gene-flow",
    "title": "Discrete trait",
    "section": "effect of gene flow",
    "text": "effect of gene flow\nWhat is the evidence that a trait was inherited via gene flow (along the minor hybrid edge) versus “vertically” (via the major hybrid edge)?\nTo answer this question, we can extract the prior probability of either option, and the posterior probabilities conditional on the data. Then, the Bayes factor to compare the 2 hypotheses, minor versus major edge (or gene flow versus vertical), can be expressed as an odds ratio: \\[\\mathrm{BF} = \\frac{P(\\mathrm{data} \\mid \\mathrm{minor})}{P(\\mathrm{data} \\mid \\mathrm{mafor})} = \\frac{\\frac{P(\\mathrm{minor} \\mid \\mathrm{data})}{P(\\mathrm{major}\\mid\\mathrm{data})}}{\\frac{P(\\mathrm{minor})}{P(\\mathrm{major})}}\\,.\\]\nHere, let’s say we want to focus on the reticulation that is ancestral to elusum (node 33, H20). From Figure 1 (left) we see that the major (“vertical”) parent edge has γ = 0.741 = P(major) and the minor (“gene flow”) edge has γ = 0.259 = P(minor). So at this reticulation, the prior odds of the trait being inherited via gene flow is 0.259/0.741 = 0.35. Here how we may get this prior odds programmatically:\n\nnodeH20 = net.node[findfirst(n->n.name==\"H20\", net.node)] # find node named H20\npriorminor = getparentedgeminor(nodeH20).gamma            # γ of its minor parent\npriorodds = priorminor / (1-priorminor)\n\n0.34993311937527516\n\n\nTo extract the posterior odds and calculate the Bayes factor, we can do as follows, to focus on just 1 reticulation of interest and integrate out what happened at other reticulations:\n\npostminor = exp(PhyloNetworks.posterior_loghybridweight(fit, \"H20\"))\npostodds = postminor / (1-postminor)\n\n0.6298935555430331\n\n\nThat’s an increase. The Bayes factor to compare the gene flow (minor edge) versus vertical (major edge) hypotheses is then:\n\npostodds / priorodds\n\n1.8000398380912406\n\n\nIt’s above 1, so there’s evidence of inheritance via gene flow, but not very much above 1 (e.g. less than 3), so it’s equivocal evidence only."
  },
  {
    "objectID": "topic6-visualization.html",
    "href": "topic6-visualization.html",
    "title": "Visualization",
    "section": "",
    "text": "Code\n# code from prior sections\nusing CSV, DataFrames, PhyloNetworks, PhyloPlots, RCall, StatsBase, StatsModels\nnet = readTopology(\"data/polemonium_network_calibrated.phy\");\nfor tip in net.node tip.name = replace(tip.name, r\"_2$\" => s\"\"); end\ntraits = CSV.read(\"data/polemonium_traits_morph.csv\", DataFrame)\nsubset!(traits, :morph => ByRow(in(tipLabels(net))))\ndat = DataFrame(morph = String.(traits[:, :morph]),\n                elevation = map( x -> (x .> 2.3 ? \"hi\" : \"lo\"), traits.elevation))\nfit = fitdiscrete(net, :ERSM, dat.morph, select(dat, :elevation))\nasr = ancestralStateReconstruction(fit)\nMany visualizations are interesting, and they are essential for communication. We give here a few examples. For each example, we suggest that you go step by step and inspect each element in the code. The more the code makes sense, the more we can customize it later for our own needs on other data sets."
  },
  {
    "objectID": "topic6-visualization.html#discrete-trait-data-at-the-tips",
    "href": "topic6-visualization.html#discrete-trait-data-at-the-tips",
    "title": "Visualization",
    "section": "discrete trait data at the tips",
    "text": "discrete trait data at the tips\nFollowing the example of a discrete trait, of high or low elevation, let’s visualize the data at the tips.\n\n\nCode\nR\"par\"(mar=[0,0,0,0]);\n# plot and save the \"res\"ult to get point coordinates, to use for adding annotation on top\nres = plot(net, tipoffset=0.5, xlim=[0.5,16]);\nres[1:4] # x and y limits\nres[13]  # info to add node annotations\nres[14]  # info to add edge annotations\n\n# find the order \"o\" in which species from data are listed in the network -- and in res\no = [findfirst(isequal(tax), dat.morph) for tax in tipLabels(net)]\ndat.morph[o] == tipLabels(net) # should be true, if order o is as intended\ntips = res[13][!,:lea]\ndat.morph[o] == res[13][tips,:name] # should be true\n\n# next: add grey & red points at the leaves\ntip_col = map(x -> (x==\"lo\" ? \"grey\" : \"red\"), dat.elevation[o])\nR\"points\"(\n    x=res[13][tips,:x] .+0.1,\n    y=res[13][tips,:y],\n    pch=16, col=tip_col, cex=1.5);\n\n# next: add a legend to say which color is for which state\nR\"legend\"(x=1, y=19, legend=[\"hi\",\"lo\"], pch=16,\n    col=[\"red\",\"grey\"], title=\"elevation\",\n    bty=\"n\", var\"title.adj\"=0); # var\"\" to allow for a dot in the variable name: R's fault...\n\n# next: add γ's for gene flow edges\nhybminor = res[14].min\nhybdf = res[14][hybminor, [:x,:y,:gam]]\nR\"text\"(hybdf.x .- 0.1, hybdf.y + 0.5.*[-1,1,1], hybdf.gam, col=\"deepskyblue\", cex=0.75);\n\n\n\n\n\nFigure 1: showing a discrete trait at the tips"
  },
  {
    "objectID": "topic6-visualization.html#ancestral-probabilities",
    "href": "topic6-visualization.html#ancestral-probabilities",
    "title": "Visualization",
    "section": "ancestral probabilities",
    "text": "ancestral probabilities\nNow let’s go one step further and visualize the probabilities of “high” and “low” elevation (as a binary trait) from this figure(b) with pie charts instead of boring hard-to-read numbers.\n\n\nCode\ncolnames = names(asr)[3:end] # to get the correct state - probability match\n# create a new column in the asr data frame, filled with the empty string \"\"\nasr[!,:fake] .= \"\"; # to add fake internal node labels later: and extract their positions\nasr # just to check\n\ncoltrait = [\"red\",\"grey\"] # or anything else: names that R knows how to interpret\n\n# start the plot\nR\"par\"(mar=[0,0,0,0]);\nres = plot(fit.net, tipoffset=0.5, xlim=[0.5,16], arrowlen=0.15,\n           nodelabel = asr[:,[:nodenumber, :fake]]);\nndf = res[13] # had locations of internal nodes, this time\n\n# add pie charts, using locations of internal nodes\nfor i in 1:nrow(asr) # loop over each row in the ancestral state reconstruction data frame\n  ii = findfirst(isequal(string(asr[!,:nodenumber][i])), ndf[!,:num]);\n  colpp = Vector(asr[i,colnames]);\n  R\"ape::floating.pie.asp\"(ndf[ii,:x], ndf[ii,:y], colpp,\n                           radius=0.2, col=coltrait);\nend\n# add legend with correct mapping of color -> state\nR\"legend\"(x=1, y=19, legend=colnames, pch=21, var\"pt.bg\"=coltrait,\n          bty=\"n\", title=\"elevation\", var\"title.adj\"=0, var\"pt.cex\"=1.5);\n\n\n\n\n\nFigure 2: pie charts to show ancestral state probabilities"
  },
  {
    "objectID": "topic6-visualization.html#continuous-trait-data-at-the-tips",
    "href": "topic6-visualization.html#continuous-trait-data-at-the-tips",
    "title": "Visualization",
    "section": "continuous trait data at the tips",
    "text": "continuous trait data at the tips\nHere is an example to vizualize the actual elevation values, at the tips.\n\n\nCode\nR\"par\"(mar=[2,0,1.5,0]);\n# plot the network with a large tip offset to leave space for bars\nres = plot(net, tipoffset=2.2, xlim=[0.5,17]);\n\n# create a standardized version of elevation, such that 0 corresponds to the mean,\n# and such that the range covers an interval of length 2:\n# for the bars to fit between the tips and the taxon names\no = [findfirst(isequal(tax), traits.morph) for tax in res[13].name] # ordering\nintervallength = 2\nstd_elev = intervallength .* standardize(UnitRangeTransform, traits.elevation[o])\nstd_elev .-= mean(std_elev) # now mean = 0, interval length still as desired\nlinecol = [(el < 0 ? \"grey\" : \"red\") for el in std_elev] # grey if elevation < mean, red if elevation > mean\nm = minimum(std_elev)    # new minimum elevation, after \"standardization\"\nx0 = res[13][1,:x] + 0.1 # x where the smallest bar should extend\nxmean = x0 - m           # x where the mean value will go\n# create the bars\nR\"segments\"(x0 = xmean, x1 = xmean .+ std_elev,\n            y0=res[13].y, col=linecol,\n            lwd=10, lend=1); # thick lines, line ends of \"butt\" type\n\n# label the horizontal axis to show the original min and max elevations\nmin_evel, max_elev = round.(extrema(traits.elevation[o]), digits=2);\nR\"axis\"(at=[x0, x0+intervallength],\n        labels=round.([min_evel,max_elev], digits=2),\n        side=1, line=-0.5, tck=-0.01);\nR\"text\"(x=x0, y=21, \"elevation (km)\", adj=0);\n\n\n\n\n\nFigure 3: bar plot to visualize continuous traits at the tips. red: above average. grey: below average"
  },
  {
    "objectID": "topic6-visualization.html#ancestral-state-for-a-continuous-trait",
    "href": "topic6-visualization.html#ancestral-state-for-a-continuous-trait",
    "title": "Visualization",
    "section": "ancestral state for a continuous trait",
    "text": "ancestral state for a continuous trait\nLet’s change and look at log-leaflet area this time. We can use a color gradient to visualize ancestral state reconstructions. The issue to keep in mind, when reading such a visualization, and that we don’t see confidence intervals, and those tend to be wider and wider as we move back in time toward the root (assuming data on extant taxa only).\n\n\nCode\n# fit the model, get ancestral state predictions\nfit_larea = phylolm(@formula(larea ~ 1), traits, net, tipnames=:morph,\n                    withinspecies_var=true, y_mean_std=true)\nasr_larea = expectations(ancestralStateReconstruction(fit_larea))\nasr_larea[!,:fake] .= \"\"; # fake empty labels\n\n\n# convert numerical ancestral states to colors, using a palette\nasr_larea_01 = standardize(UnitRangeTransform, asr_larea.condExpectation) # values ranging in 0-1\n@rlibrary viridis\nmypalette = rcopy(viridis(256)) # 256 possible colors in the palette\nimport CategoricalArrays: cut\nbreaks = [i/256 for i in 0:256]\nasr_larea_index = convert(Vector{Int}, cut(asr_larea_01, breaks; extend=true, labels=1:256))\nasr_larea_colr = mypalette[asr_larea_index]\n\n# start the plot\nR\"par\"(mar=[0,0,0,0]);\nres = plot(net, tipoffset=0.5, xlim=[0.5,16],\n           nodelabel = asr_larea[:,[:nodeNumber, :fake]]);\n\n# find order to match tips between asr_larea and res[13]\nndf = res[13]\no = [findfirst(isequal(nn), asr_larea.nodeNumber) for nn in parse.(Int, ndf.num)]\nasr_larea.nodeNumber[o] == parse.(Int, ndf.num) # should be true\n\n# add the colored circles\nR\"points\"(x=ndf.x, y=ndf.y, pch=16, col=asr_larea_colr[o], cex=1.5);\n\n# add legend\nm,M = string.(round.(extrema(asr_larea.condExpectation), digits=2))\nR\"legend\"(x=0, y=19, bty=\"n\", adj=0, var\"y.intersp\"=0.5, border=\"NA\",\n    legend = [m,\"\",\"\",\"\",M], fill = mypalette[[1, 64, 128, 192, 256]]);\n\n\n\n\n\nFigure 4: prediction of mean log-leaflet area (not showing uncertainty)"
  },
  {
    "objectID": "topic7-averagedistances.html",
    "href": "topic7-averagedistances.html",
    "title": "Average distances",
    "section": "",
    "text": "Code\n# code from prior sections: load packages used here\nusing CSV, DataFrames, PhyloNetworks, StatsBase\n\n\nThis extra section provides example code to estimate genetic distances from gene trees, which them may later be used to calibrate a network.\nUsing gene trees from multiple loci may be best when loci are sufficiently informative. With short loci or with loci with few informative sites, some branch lengths may often be underestimated at 0 due to a lack of variable sites, in which case it may be best to estimate genetic distances from the multiple alignment directly.\nIf loci are sufficiently informative, estimating a gene tree from each locus may help reduce noise in the estimated distances (e.g. account for multiple substitutions along the same lineage). It can also decrease the influence of fast-evolving genes, and rate variation across genes more generally.\nWe first define helper functions for computing pairwise distances, to - get a matrix pairwise distances from each tree - normalize these distance matrices, so they all have a similar distance between the ingroup and outgroup taxa - average distance matrices across genes. These functions were originally developed by Karimi et al. (2020). Their code was slightly modified here. To load these helper functions: unfold the code below, then copy & paste into your julia session.\n\n\nCode\n\"\"\"\n    getpairwisedistances(genetrees, taxa)\n\nReturn a tuple of 3 objects:\n1. A vector `D` of matrices, one per gene tree, containing the pairwise distance\n   between all pairs of `taxa`. If taxon i is missing from tree `k`, then the\n   distance matrix `D[k]` for that tree will have zeros on its ith row and ith column.\n   In each matrix, row & column `i` correspond to `taxa[i]`, that is, taxa are\n   listed in the same order as in the input `taxa`.\n2. A matrix `ngenes` containing the number of genes with data on the pair\n   of taxa (i,j) in row i, column j\n3. A vector of integers, giving the index of gene trees with some missing taxa.\n\nThis function uses `pairwiseTaxonDistanceMatrix(tree)` from `PhyloNetworks`,\nwhich outputs a matrix in which the rows correspond to taxa in the order in\nwhich they come in `tipLabels(tree)`.\nIt then takes care of the fact that taxa may not be listed in the same order by\n`tipLabels` across all gene trees.\n\"\"\"\nfunction getpairwisedistances(genetrees, taxa)\n  ntips = length(taxa)\n  D = Array{Float64,2}[]; # empty vector. will contain all distance matrices\n  ngenes = zeros(Int, ntips, ntips) # number of genes that have data for each pair\n  geneind = Int[];        # indices of genes with missing taxa\n  istaxonmissing = Vector{Bool}(undef, ntips) # to be modified in place for each gene\n  for (g_index,g) in enumerate(genetrees)\n    M = zeros(ntips,ntips) # initialized at 0.0: for missing pairs\n    taxnames = tipLabels(g)\n    tipind = Int[]\n    for k in 1:ntips\n      j = findfirst(isequal(taxa[k]), taxnames)\n      notfound = isnothing(j)\n      istaxonmissing[k] = notfound # modified in place\n      notfound || push!(tipind, j) # add j to tipind if taxa[k] was found\n    end\n    M[.!istaxonmissing, .!istaxonmissing] = pairwiseTaxonDistanceMatrix(g)[tipind,tipind]\n    ngenes[.!istaxonmissing, .!istaxonmissing] .+= 1\n    any(istaxonmissing) && push!(geneind,g_index)\n    push!(D, M)\n  end\n  return D, ngenes, geneind\nend\n\n\"\"\"\n    normalizedistances_outgroup2ingroup!(D; taxa, ingroup, outgroup)\n\nRescale each input distance matrix `D[k]`, such that all have the same\nmedian patristic distance between outgroup taxa and ingroup taxa.\nInput: `D` should be a vector of pairwise distances matrices, one per gene\n(modified by the function).\nOutput: vector of original median ingroup-outgroup distance, one per gene.\n\nWhy the *median*? So that one taxon or one small clade with an unusually large\n(or low) substitution rate does have an undue influence on the scaling factor.\n\nAssumptions:\n- all trees have at least 1 outgroup and 1 ingroup\n- row & column `i` in D[k] (for gene k) correspond to `taxa[i]`\n- `D[k][i,j]` = 0 if gene `k` doesn't have both taxa `i` and `j`\n- `ingroup` and `outgroup` are sets. The function does *not* check whether they\n  are subsets of `taxa`, or don't overlap, or cover the full set of `taxa`.\n\"\"\"\nfunction normalizedistances_outgroup2ingroup!(D; taxa, ingroup, outgroup)\n  ntax = length(taxa)\n  inding = findall(in(ingroup),  taxa) # indices of ingroup  taxa\n  indout = findall(in(outgroup), taxa) # indices of outgroup taxa\n  medianingroup2outgroup = Float64[]   # will contain 1 median per gene\n  for dm in D # dm = distance matrix\n    size(dm) = (ntax,ntax) || error(\"there's a distance matrix with wrong dimensions: $(size(dm))\")\n    absent = findall([all(dm[:,i] .== 0.0) for i in 1:ntax])\n    push!(medianingroup2outgroup,\n          median(dm[setdiff(inding, absent), setdiff(indout, absent)]) )\n  end\n  mi2o = mean(medianingroup2outgroup)\n  for k in 1:length(D)\n    D[k] .*= mi2o/medianingroup2outgroup[k]\n  end\n  return medianingroup2outgroup\nend\n\n\"\"\"\n    averagepairwisedistances(D, ngenes)\n\nMatrix `M` containing the average pairwise distances, weighted by number of\ngenes with data on the pair: M[i,j] = (sum_k D[k][i,j] ) / ngenes[i,j].\nThis is because for each pair of taxa `i,j`, it is assumed that a number\n`ngenes[i,j]` of genes (indexed by k) contributed data for the pair, and\nthe other genes without both taxa i and j had D[k][i,j]=0.\n\"\"\"\nfunction averagepairwisedistances(D, ngenes)\n  return sum(D) ./ ngenes\nend\n\n\nThis tutorial comes with a small sample of gene trees, some of them modified so as to illustrate the case when taxa are missing from some genes. These gene tree files are in folder data/genetrees_sample, and are majority-rule consensus trees in nexus format created by MrBayes. This is only to give example code to read gene tree files and calculate distances. In practice, the majority-rule creates edges of length 0 (polytomies) when there is less than 50% credibility for a resolution in the gene tree, so this is underestimating the true edge length, and a full consensus tree may be a better option.\nBelow, we show how to read these files using readNexusTrees because of the nexus format. This function is meant to read a sample of multiple trees (or multiple networks), so it returns a list. We only use the first and only tree in this list. As we can see, loci 10 and 20 are missing a few taxa.\n\ngenetreefolder = joinpath(\"data\",\"genetrees_sample\")\n# list the content of this folder, and filter to keep files ending in \".tre\":\ngenetreefiles = filter(x -> endswith(x,\".tre\"), readdir(genetreefolder))\nlength(genetreefiles) # 19 files: L22 missing\nfunction read1gene(filename)\n  genetreefile = joinpath(genetreefolder, filename)\n  return readNexusTrees(genetreefile)[1] # first and only tree in the list\nend\ngenetrees = map(read1gene, genetreefiles)\nfor (filename,tree) in zip(genetreefiles, genetrees)\n  println(\"$filename: $(tree.numTaxa) taxa\")\nend\n\nT405_L10.nex.con.tre: 14 taxa\nT405_L11.nex.con.tre: 17 taxa\nT405_L12.nex.con.tre: 17 taxa\nT405_L13.nex.con.tre: 17 taxa\nT405_L14.nex.con.tre: 17 taxa\nT405_L15.nex.con.tre: 17 taxa\nT405_L16.nex.con.tre: 17 taxa\nT405_L17.nex.con.tre: 17 taxa\nT405_L18.nex.con.tre: 17 taxa\nT405_L19.nex.con.tre: 17 taxa\nT405_L20.nex.con.tre: 16 taxa\nT405_L21.nex.con.tre: 17 taxa\nT405_L23.nex.con.tre: 17 taxa\nT405_L24.nex.con.tre: 17 taxa\nT405_L25.nex.con.tre: 17 taxa\nT405_L26.nex.con.tre: 17 taxa\nT405_L27.nex.con.tre: 17 taxa\nT405_L28.nex.con.tre: 17 taxa\nT405_L29.nex.con.tre: 17 taxa\n\n\nTo convert each tree to a matrix of pairwise distances, we first need to decide the order in which the taxa should be listed.\n\ntaxa_long = sort!(union([tipLabels(tree) for tree in genetrees]...))\nD, ngenes, geneind = getpairwisedistances(genetrees, taxa_long);\ngeneind # indices of genes with some missing taxa\n\n2-element Vector{Int64}:\n  1\n 11\n\n\n\nngenes # number of genes with data for each pair: 19 for most, some 17's and 18's\n\n17×17 Matrix{Int64}:\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 17  17  17  17  17  17  17  17  17  17  17  17  17  17  17  17  17\n 18  18  18  18  18  18  18  17  18  18  18  18  18  18  18  18  18\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 18  18  18  18  18  18  18  17  18  18  18  18  18  18  18  18  18\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n 19  19  19  19  19  19  19  17  18  19  19  19  18  19  19  19  19\n\n\n\nD[11] # distance matrix from 11th gene in the list. if missing taxa, then 0s\n\n17×17 Matrix{Float64}:\n 0.0         0.031831   0.0261231  …  0.0407398  0.0113065   0.0381869\n 0.031831    0.0        0.0191849     0.0272717  0.0307095   0.035106\n 0.0261231   0.0191849  0.0           0.0280938  0.0250017   0.0293982\n 0.0407076   0.0376267  0.0319188     0.0465355  0.0395861   0.00606439\n 0.0324402   0.0293594  0.0236515     0.0382682  0.0313188   0.0283365\n 0.0402938   0.0372129  0.031505   …  0.0461218  0.0391723   0.029748\n 0.0107768   0.0301798  0.024472      0.0390887  0.00965534  0.0365358\n 0.0         0.0        0.0           0.0        0.0         0.0\n 0.00702223  0.0264253  0.0207174     0.0353341  0.00590078  0.0327812\n 0.00695353  0.0263566  0.0206487     0.0352654  0.00583209  0.0327125\n 0.00697372  0.0263767  0.0206689  …  0.0352856  0.00585227  0.0327327\n 0.0279844   0.0335855  0.0278776     0.0424944  0.0268629   0.0399415\n 0.00695846  0.0263615  0.0206536     0.0352704  0.00583701  0.0327174\n 0.0365629   0.0230947  0.0239168     0.0198704  0.0354414   0.039838\n 0.0407398   0.0272717  0.0280938     0.0        0.0396184   0.0440149\n 0.0113065   0.0307095  0.0250017  …  0.0396184  0.0         0.0370655\n 0.0381869   0.035106   0.0293982     0.0440149  0.0370655   0.0\n\n\nNow we want to rescale each distance matrix so as to limit the impact of rate variation across genes. Otherwise, fast-evolving genes would overwhelm the signal, which may be particularly dangerous if these fast-evolving genes have saturated edge lengths or are affected by long-branch attraction.\nFor normalizing the median distance between all pairs of ingroup-outgroup taxa, we define these sets of taxa:\n\noutgroup = filter(x -> occursin(\"micranthum\",x), taxa_long)\ningroup = setdiff(taxa_long, outgroup)\nmed_in2out = normalizedistances_outgroup2ingroup!(D,\n  taxa=taxa_long, ingroup=ingroup, outgroup=outgroup);\nmed_in2out\n\n19-element Vector{Float64}:\n 0.028521906\n 0.019770464\n 0.017636436499999998\n 0.0224220723\n 0.028571541\n 0.038314872\n 0.050856829650000004\n 0.039494405\n 0.0235365128\n 0.0321006079\n 0.038268231\n 0.018588236999999997\n 0.0256485685\n 0.013689591000000001\n 0.00205620645\n 0.032686909\n 0.0434885215\n 0.0146293095\n 0.009773589499999999\n\n\nWe can see that all genes had somewhat similar rates, because similar median ingroup-to-outgroup distances, except for gene 15, that had a particularly smaller rate than others. If there is reason to think that slow-evolving genes may need to be removed, a filtering step could be added at this point. For the sake of providing example code, we do this here.\n\nslowgene_indices = findall(d -> d < 0.003, med_in2out) # gene 15 here\n\n1-element Vector{Int64}:\n 15\n\n\nGene 15 was not missing any taxa: geneind did not list that gene. So we don’t have to re-run the calculation of the vector of D matrix and of the matrix storing the number of genes contributing data for each pair of taxa. Otherwise, we would need to re-run the calculation of ngenes.\n\ndeleteat!(D, slowgene_indices); # deletes D[k] for a slow gene k\nnum_slow = length(slowgene_indices) # 1: number of slow genes that are being exluded\nngenes .-= num_slow # gene 15 was not missing any taxa\nlength(D) # 18: 1 fewer than before\n\n18\n\n\nNow we can see how the distance matrix changed for the first gene, which we looked at earlier:\n\nD[11] # from 11th gene, after normalization. 0s on rows & columns for missing taxa\n\n17×17 Matrix{Float64}:\n 0.0         0.0218915  0.017966   …  0.0280185  0.00777595  0.0262628\n 0.0218915   0.0        0.0131943     0.0187559  0.0211202   0.0241439\n 0.017966    0.0131943  0.0           0.0193213  0.0171947   0.0202184\n 0.0279963   0.0258774  0.0219519     0.0320045  0.027225    0.00417073\n 0.0223105   0.0201917  0.0162661     0.0263187  0.0215393   0.0194882\n 0.0277117   0.0255929  0.0216673  …  0.0317199  0.0269405   0.0204589\n 0.00741165  0.0207559  0.0168304     0.0268829  0.00664039  0.0251272\n 0.0         0.0        0.0           0.0        0.0         0.0\n 0.00482948  0.0181738  0.0142482     0.0243008  0.00405822  0.022545\n 0.00478224  0.0181265  0.014201      0.0242535  0.00401097  0.0224978\n 0.00479612  0.0181404  0.0142149  …  0.0242674  0.00402485  0.0225117\n 0.019246    0.0230982  0.0191726     0.0292252  0.0184748   0.0274694\n 0.00478562  0.0181299  0.0142044     0.0242569  0.00401436  0.0225012\n 0.0251458   0.0158832  0.0164486     0.0136657  0.0243746   0.0273982\n 0.0280185   0.0187559  0.0193213     0.0        0.0272472   0.0302709\n 0.00777595  0.0211202  0.0171947  …  0.0272472  0.0         0.0254915\n 0.0262628   0.0241439  0.0202184     0.0302709  0.0254915   0.0\n\n\nFinally, let’s average distances across genes\n\navD = averagepairwisedistances(D, ngenes)\n\n17×17 Matrix{Float64}:\n 0.0        0.025131   0.0166456  …  0.0333717  0.0204769  0.0221704\n 0.025131   0.0        0.0201658     0.0288717  0.0161611  0.0170719\n 0.0166456  0.0201658  0.0           0.0314511  0.0187754  0.0191991\n 0.0167357  0.0204018  0.012726      0.0325606  0.0202637  0.0158341\n 0.0173756  0.0195113  0.0129158     0.0316148  0.0196154  0.0206315\n 0.0246931  0.0204742  0.0210903  …  0.0281747  0.0168907  0.01409\n 0.0180386  0.017438   0.0202813     0.0293285  0.0154165  0.0160886\n 0.0218215  0.0203966  0.0241864     0.0308539  0.017866   0.0173078\n 0.0198536  0.0154942  0.0183717     0.0255542  0.0122323  0.0132618\n 0.0213477  0.0148121  0.0182099     0.0251534  0.0129911  0.0109218\n 0.0130298  0.0221036  0.0126574  …  0.0314761  0.0164174  0.0202386\n 0.0181169  0.0254095  0.0138355     0.0301603  0.0199716  0.0212204\n 0.0175151  0.0144697  0.0180279     0.0253002  0.010981   0.0114824\n 0.0221586  0.0148132  0.0163897     0.0241507  0.0123825  0.0128827\n 0.0333717  0.0288717  0.0314511     0.0        0.0249235  0.0244055\n 0.0204769  0.0161611  0.0187754  …  0.0249235  0.0        0.0146991\n 0.0221704  0.0170719  0.0191991     0.0244055  0.0146991  0.0\n\n\nand save this average distance matrix to a file:\n\ncsv_filename = joinpath(genetreefolder, \"averagedist_sample.csv\")\navD_df = DataFrame([avD[:,j] for j in 1:size(avD,2)], # column data\n                   [Symbol(t) for t in taxa_long])    # column names\nCSV.write(csv_filename, avD_df)\n\n\"data/genetrees_sample/averagedist_sample.csv\""
  }
]